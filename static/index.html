<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>YOLOv11 Live Detection</title>
    <style>
        body {
            background: #1a1a1a;
            color: #eee;
            font-family: sans-serif;
            text-align: center;
        }

        h2 {
            color: #ff4b2b;
        }

        #wrapper {
            position: relative;
            display: inline-block;
            border: 4px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        video {
            display: block;
            width: 640px;
            height: 480px;
            background: #000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
        }

        .info {
            margin-top: 10px;
            font-size: 0.9em;
            color: #888;
        }
    </style>
</head>

<body>

    <h2>ðŸ”¥ Smoke & Fire Detection</h2>

    <div id="wrapper">
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
    </div>

    <div class="info">API Status: <span id="status">Connecting...</span></div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const statusLabel = document.getElementById('status');

        // 1. Access the MacBook Camera
        navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
            .then(stream => {
                video.srcObject = stream;
                statusLabel.innerText = "Active";
                statusLabel.style.color = "#00ff00";
            })
            .catch(err => {
                statusLabel.innerText = "Camera Error: " + err;
                statusLabel.style.color = "#ff0000";
            });

        // 2. Capture and Send Frames
        async function processFrame() {
            if (video.readyState !== 4) return; // Wait for video to be ready

            // Create a temporary canvas to grab the frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0);

            tempCanvas.toBlob(async (blob) => {
                const formData = new FormData();
                formData.append('file', blob, 'frame.jpg');

                try {
                    const response = await fetch('http://127.0.0.1:8000/detect', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();

                    // Draw the results
                    drawBoxes(data.detections);
                } catch (error) {
                    console.error("API Error:", error);
                }
            }, 'image/jpeg', 0.8);
        }

        // 3. Draw Bounding Boxes
        function drawBoxes(detections) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Adjust for difference between camera resolution and display size
            const scaleX = canvas.width / video.videoWidth;
            const scaleY = canvas.height / video.videoHeight;

            detections.forEach(det => {
                const [x1, y1, x2, y2] = det.box;

                // Draw Box
                ctx.strokeStyle = "#ff4b2b";
                ctx.lineWidth = 4;
                ctx.strokeRect(x1 * scaleX, y1 * scaleY, (x2 - x1) * scaleX, (y2 - y1) * scaleY);

                // Draw Label
                ctx.fillStyle = "#ff4b2b";
                ctx.font = "bold 16px Arial";
                const labelText = `${det.label} ${(det.confidence * 100).toFixed(1)}%`;
                ctx.fillText(labelText, x1 * scaleX, (y1 * scaleY) - 10);
            });
        }

        // Run detection every 300ms (adjust for performance)
        setInterval(processFrame, 300);
    </script>
</body>

</html>